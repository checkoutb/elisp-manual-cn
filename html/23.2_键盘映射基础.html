<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="elisp.css"><title>23.2 键盘映射基础</title></head><body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000"><h2 class="section">23.2 键盘映射基础</h2>
<div class="nav-panel"><p>Next: <a href="23.3_键盘映射格式.html">键盘映射格式</a>, Previous: <a href="23.1_按键序列.html">按键序列</a>, Up: <a href="23_键盘映射.html">键盘映射.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html><hr/><p>键映射是一种 Lisp 数据结构，它为各种键序列指定键绑定。
</p>
<p>单个键映射直接指定各个事件的定义。当键序列由单个事件组成时，它在键映射中的绑定就是该事件的键映射定义。一个较长的键序列的绑定是通过一个迭代过程找到的：首先找到第一个事件的定义（它本身必须是一个键映射）；  然后在该键映射中找到第二个事件的定义，依此类推，直到键序列中的所有事件都已被处理。
</p>
<p>如果键序列的绑定是一个键映射，我们称该键序列为前缀键。否则，我们称它为一个完整的键（因为它不能再添加任何事件）。如果绑定为 nil，我们称键未定义。前缀键的示例是 Cc、Cx 和 Cx 4。定义的完整键的示例是 X、RET 和 Cx 4 Cf。未定义的完整键的示例是 Cx Cg 和 Cc 3。有关详细信息，请参阅前缀键。
</p>
<p>查找键序列绑定的规则假定中间绑定（为最后一个事件之前的事件找到）都是键映射；  如果不是这样，则事件序列不会形成一个单元——它实际上不是一个键序列。换句话说，从任何有效键序列的末尾删除一个或多个事件必须始终产生一个前缀键。例如，Cf Cn 不是键序列；  Cf 不是前缀键，因此以 Cf 开头的较长序列不能是键序列。
</p>
<p>可能的多事件键序列集取决于前缀键的绑定；  因此，不同的键盘映射可能会有所不同，并且可以在更改绑定时更改。但是，单事件序列始终是键序列，因为它的格式良好不依赖于任何前缀键。
</p>
<p>在任何时候，都有几个主键映射处于活动状态，即用于查找键绑定。这些是全局映射，由所有缓冲区共享；  本地键盘映射，通常与特定的主要模式相关联；  和零个或多个次要模式键盘映射，它们属于当前启用的次要模式。（并非所有次要模式都有键映射。）本地键映射绑定会影响（即优先于）相应的全局绑定。次要模式键映射会影响本地和全局键映射。有关详细信息，请参阅活动键盘映射。
</p>
<hr/>

<div class="nav-panel"><p>Next: <a href="23.3_键盘映射格式.html">键盘映射格式</a>, Previous: <a href="23.1_按键序列.html">按键序列</a>, Up: <a href="23_键盘映射.html">键盘映射.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html>
<script>document.onkeydown=checkKey;function checkKey(e){if(e.keyCode=='39'){location="23.3_键盘映射格式.html";}else if(e.keyCode=='37'){location="23.1_按键序列.html" } }</script>