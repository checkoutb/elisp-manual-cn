<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="elisp.css"><title>29.9 重新组合窗口</title></head><body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000"><h2 class="section">29.9 重新组合窗口</h2>
<div class="nav-panel"><p>Next: <a href="29.10_Windows的循环排序.html">Windows的循环排序</a>, Previous: <a href="29.8_删除窗口.html">删除窗口</a>, Up: <a href="29_窗口.html">窗口.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html><hr/><p>当删除窗口 W 的最后一个兄弟时，它的父窗口也被删除，W 在窗口树中替换它。这意味着 W 必须与其父级的兄弟重新组合以形成新的窗口组合（请参阅窗口和 <code>帧</code> ( <code>frame</code> )）。在某些情况下，删除一个实时窗口甚至可能需要删除两个内部窗口。
</p><div class="lisp">
<pre class="lisp"> ______________________________________
| ______  ____________________________ |
||      || __________________________ ||
||      ||| ___________  ___________ |||
||      ||||           ||           ||||
||      ||||____W6_____||_____W7____||||
||      |||____________W4____________|||
||      || __________________________ ||
||      |||                          |||
||      |||                          |||
||      |||____________W5____________|||
||__W2__||_____________W3_____________ |
|__________________W1__________________|
</pre></div>
<p>在此配置中删除 W5 通常会导致删除 W3 和 W4。剩余的活动窗口 W2、W6 和 W7 重新组合以与父 W1 形成新的水平组合。
</p>
<p>然而，有时不删除像 W4 这样的父窗口是有意义的。特别是，当父窗口用于保留嵌入在相同类型组合中的组合时，不应将其删除。这样的嵌入可以确保当您拆分一个窗口并随后删除新窗口时，Emacs 会重新建立关联 <code>帧</code> ( <code>frame</code> )的布局，因为它在拆分之前存在。
</p>
<p>考虑从两个实时窗口 W2 和 W3 及其父窗口 W1 开始的场景。
</p><div class="lisp">
<pre class="lisp">______________________________________
| ____________________________________ |
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||_________________W2_________________||
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W3_________________||
|__________________W1__________________|
</pre></div>
<p>拆分 W2 以创建一个新窗口 W4，如下所示。
</p><div class="lisp">
<pre class="lisp"> ______________________________________
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W2_________________||
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W4_________________||
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W3_________________||
|__________________W1__________________|
</pre></div>
<p>现在，当垂直放大一个窗口时，Emacs 会尝试从它的下层兄弟那里获取相应的空间，前提是存在这样的窗口。在我们的场景中，扩大 W4 将从 W3 中窃取空间。
</p><div class="lisp">
<pre class="lisp">______________________________________
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W2_________________||
| ____________________________________ |
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||_________________W4_________________||
| ____________________________________ |
||_________________W3_________________||
|__________________W1__________________|

</pre></div>
<p>删除 W4 现在会将其整个空间分配给 W2，包括之前从 W3 窃取的空间。
</p><div class="lisp">
<pre class="lisp">| ____________________________________ |
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||_________________W2_________________||
| ____________________________________ |
||_________________W3_________________||
|__________________W1__________________|

</pre></div>
<p>这可能违反直觉，特别是如果 W4 仅用于临时显示缓冲区（请参阅临时显示），并且您希望继续使用初始布局。
</p>
<p>可以通过在拆分 W2 时创建一个新的父窗口来修复该行为。接下来描述的变量允许这样做。
</p>
<div class="lisp">
<pre class="lisp">User Option: window-combination-limit ¶
</pre></div>
<p>此变量控制拆分窗口是否应生成新的父窗口。识别以下值：
</p>
<div class="lisp">
<pre class="lisp">nil
</pre></div>
<p>这意味着允许新的活动窗口共享现有的父窗口（如果存在），前提是拆分发生在与现有窗口组合相同的方向（否则，无论如何都会创建一个新的内部窗口）。
</p><div class="lisp">
<pre class="lisp">window-size
</pre></div>
<p>这意味着 display-buffer 在拆分窗口时会创建一个新的父窗口，并在 alist 参数中传递一个 window-height 或 window-width 条目（请参阅缓冲区显示的操作函数）。否则，窗口拆分的行为与 nil 值相同。
</p><div class="lisp">
<pre class="lisp">temp-buffer-resize
</pre></div>
<p>在这种情况下，with-temp-buffer-window 在拆分窗口并启用 temp-buffer-resize-mode 时会创建一个新的父窗口（请参阅临时显示）。否则，窗口拆分的行为与 nil 相同。
</p><div class="lisp">
<pre class="lisp">temp-buffer
</pre></div>
<p>在这种情况下，with-temp-buffer-window 在拆分现有窗口时总是会创建一个新的父窗口（请参阅临时显示）。否则，窗口拆分的行为与 nil 相同。
</p><div class="lisp">
<pre class="lisp">display-buffer
</pre></div>
<p>这意味着当 display-buffer（请参阅为显示缓冲区选择窗口）拆分窗口时，它总是会创建一个新的父窗口。否则，窗口拆分的行为与 nil 相同。
</p><div class="lisp">
<pre class="lisp">t
</pre></div>
<p>这意味着拆分窗口总是会创建一个新的父窗口。因此，如果此变量的值始终为 t，则始终每个窗口树都是二叉树（除了根窗口之外的每个窗口都只有一个兄弟节点的树）。
</p>
<p>默认值为窗口大小。其他值保留供将来使用。
</p>
<p>如果由于该变量的设置，split-window 创建了一个新的父窗口，它还会在新创建的内部窗口上调用 set-window-combination-limit（见下文）。这会影响删除子窗口时窗口树的重新排列方式（见下文）。
</p>
<p>如果 window-combination-limit 是 t，在我们场景的初始配置中拆分 W2 会产生这样的结果：
</p><div class="lisp">
<pre class="lisp"> ______________________________________
| ____________________________________ |
|| __________________________________ ||
|||                                  |||
|||________________W2________________|||
|| __________________________________ ||
|||                                  |||
|||________________W4________________|||
||_________________W5_________________||
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W3_________________||
|__________________W1__________________|

</pre></div>
<p>已创建新的内部窗口 W5；  它的孩子是 W2 和新的直播窗口 W4。现在，W2 是 W4 的唯一兄弟，因此扩大 W4 会尝试缩小 W2，而不会影响 W3。观察 W5 表示嵌入在垂直组合 W1 中的两个窗口的垂直组合。
</p>
<div class="lisp">
<pre class="lisp">Function: set-window-combination-limit window limit ¶
</pre></div>
<p>该函数将窗口窗口的组合限制设置为限制。该值可以通过函数 window-combination-limit 检索。其效果见下文；  请注意，它仅对内部窗口有意义。split-window 函数自动调用此函数，将 t 作为 limit 传递，前提是调用时变量 window-combination-limit 的值为 t。
</p>
<div class="lisp">
<pre class="lisp">Function: window-combination-limit window ¶
</pre></div>
<p>此函数返回窗口的组合限制。
</p>
<p>组合限制仅对内部窗口有意义。如果为 nil，则允许 Emacs 自动删除窗口，以响应窗口删除，以便将 window 的子窗口与其兄弟窗口分组，形成新的窗口组合。如果组合限制为 t，则 window 的子窗口永远不会自动与其兄弟窗口重新组合。
</p>
<p>如果在本节开头显示的配置中，W4（W6 和 W7 的父窗口）的组合限制为 t，则删除 W5 也不会隐式删除 W4。
</p>
<p>或者，可以通过在拆分或删除其中一个窗口时始终以相同组合调整所有窗口的大小来避免上述问题。这也允许拆分窗口，否则这些窗口对于这种操作来说太小了。
</p>
<div class="lisp">
<pre class="lisp">User Option: window-combination-resize ¶
</pre></div>
<p>如果此变量为 nil，则 split-window 只能在窗口的屏幕区域足够大以容纳其自身和新窗口的情况下拆分窗口（用 window 表示）。
</p>
<p>如果这个变量是 t，split-window 会尝试调整与 window 相同组合的所有窗口的大小，以适应新窗口。特别是，即使窗口是固定大小的窗口或太小而无法正常拆分，这也可能允许拆分窗口成功。此外，随后调整或删除窗口的大小可能会调整其组合中的所有其他窗口的大小。
</p>
<p>默认值为无。其他值保留供将来使用。如果特定的拆分操作受 window-combination-limit 的非 nil 值影响，则可能会忽略此变量的值。
</p>
<p>为了说明窗口组合调整大小的效果，请考虑以下 <code>帧</code> ( <code>frame</code> )布局。
</p><div class="lisp">
<pre class="lisp"> ______________________________________
| ____________________________________ |
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||_________________W2_________________||
| ____________________________________ |
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||_________________W3_________________||
|__________________W1__________________|

</pre></div>
<p>如果 window-combination-resize 为 nil，则拆分窗口 W3 使 W2 的大小保持不变：
</p><div class="lisp">
<pre class="lisp"> ______________________________________
| ____________________________________ |
||                                    ||
||                                    ||
||                                    ||
||                                    ||
||_________________W2_________________||
| ____________________________________ |
||                                    ||
||_________________W3_________________||
| ____________________________________ |
||                                    ||
||_________________W4_________________||
|__________________W1__________________|
</pre></div>
<p>如果 window-combination-resize 为 t，则拆分 W3 会使所有三个活动窗口的高度大致相同：
</p><div class="lisp">
<pre class="lisp"> ______________________________________
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W2_________________||
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W3_________________||
| ____________________________________ |
||                                    ||
||                                    ||
||_________________W4_________________||
|__________________W1__________________|
</pre></div>
<p>删除任何活动窗口 W2、W3 或 W4 将在剩余的两个活动窗口之间按比例分配其空间。
</p>
<hr/>

<div class="nav-panel"><p>Next: <a href="29.10_Windows的循环排序.html">Windows的循环排序</a>, Previous: <a href="29.8_删除窗口.html">删除窗口</a>, Up: <a href="29_窗口.html">窗口.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html>
<script>document.onkeydown=checkKey;function checkKey(e){if(e.keyCode=='39'){location="29.10_Windows的循环排序.html";}else if(e.keyCode=='37'){location="29.8_删除窗口.html" } }</script>