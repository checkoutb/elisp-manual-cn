<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="elisp.css"><title>40.26 双向显示</title></head><body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000"><h2 class="section">40.26 双向显示</h2>
<div class="nav-panel"><p>Next: <a href="41_操作系统接口.html">操作系统接口</a>, Previous: <a href="40.25_工具提示.html">工具提示</a>, Up: <a href="40_Emacs显示.html">Emacs显示.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html><hr/><p>Emacs 可以显示用脚本编写的文本，例如阿拉伯语、波斯语和希伯来语，其水平文本显示的自然顺序是从右到左。此外，嵌入在从右到左的文本中的拉丁字母和数字段从左到右显示，而从左到右的文本中嵌入的从右到左的脚本段（例如，评论中的阿拉伯语或希伯来语文本）或程序源文件中的字符串）适当地从右到左显示。我们将这种从左到右和从右到左文本的混合称为双向文本。本节介绍用于编辑和显示双向文本的工具和选项。
</p>
<p>文本以逻辑（或阅读）顺序存储在 Emacs 缓冲区和字符串中，即人类阅读每个字符的顺序。在从右到左和双向文本中，字符在屏幕上的显示顺序（称为视觉顺序）与逻辑顺序不同；  字符的屏幕位置不会随字符串或缓冲区位置单调增加。在执行这种双向重新排序时，Emacs 遵循 Unicode 双向算法（又名 UBA），该算法在 Unicode 标准（<a href="https://www.unicode.org/reports/tr9/）的附件">https://www.unicode.org/reports/tr9/）的附件</a> #9 中进行了描述。Emacs 提供了 UBA 的 <code>完全双向</code> 类实现，符合 Unicode 标准 v9.0 的要求。但是请注意，当文本方向与基本段落方向相反时，Emacs 显示续行的方式与 UBA 有所不同，UBA 需要在重新排序文本以进行显示之前执行换行。
</p>
<div class="lisp">
<pre class="lisp">
Variable: bidi-display-reordering ¶
</pre></div>
<p>如果这个缓冲区局部变量的值是非零（默认值），Emacs 执行双向重新排序以进行显示。重新排序会影响缓冲区文本，以及缓冲区中文本和覆盖属性的显示字符串和覆盖字符串（请参阅覆盖属性和显示属性）。如果值为 nil，则 Emacs 不会在缓冲区中执行双向重新排序。
</p>
<p>bidi-display-reordering 的默认值控制不直接由缓冲区提供的字符串的重新排序，包括显示在模式行（请参阅模式行格式）和标题行（请参阅窗口标题行）中的文本。
</p>
<p>Emacs 从不重新排序单字节缓冲区的文本，即使缓冲区中的双向显示重新排序不为零。这是因为单字节缓冲区包含原始字节，而不是字符，因此缺乏重新排序所需的方向性属性。因此，要测试缓冲区中的文本是否会被重新排序以进行显示，仅测试bidi-display-reordering 的值是不够的。正确的测试是这样的：
</p>
<div class="lisp">
<pre class="lisp">(if (and enable-multibyte-characters
         bidi-display-reordering)
    ;; Buffer is being reordered for display
  )
</pre></div>
<p>但是，如果它们的父缓冲区被重新排序，则单字节显示和覆盖字符串会被重新排序。这是因为 Emacs 将纯 ASCII 字符串存储为单字节字符串。如果单字节显示或覆盖字符串包含非 ASCII 字符，则假定这些字符具有从左到右的方向。
</p>
<p>由显示文本属性覆盖的文本、由值为字符串的显示属性覆盖的文本以及由替换缓冲区文本的任何其他属性覆盖的文本，在重新排序以进行显示时将被视为一个单元。也就是说，这些属性覆盖的整个文本块被重新排序在一起。此外，这样一个文本块中字符的双向属性被忽略了，Emacs 将它们重新排序，就好像它们被替换为单个字符 U+FFFC，称为对象替换字符。这意味着将显示属性放置在部分文本上可能会改变周围文本重新排序以进行显示的方式。为防止出现这种意外效果，请始终将此类属性放置在方向性与其周围文本相同的文本上。
</p>
<p>双向文本的每个段落都有一个基本方向，从右到左或从左到右。从左到右的段落从窗口的左边距开始显示，并在文本到达右边距时被截断或继续。从右到左的段落从右边距开始显示，并在左边距继续或截断。
</p>
<p>就 Emacs UBA 实现而言，段落的确切开始和结束位置由以下两个缓冲区局部变量确定（请注意，段落开始和段落分隔对此没有影响）。默认情况下，这两个变量都为 nil，段落以空行为界，即完全由零个或多个空格字符组成的行，后跟换行符。
</p>
<div class="lisp">
<pre class="lisp">
Variable: bidi-paragraph-start-re ¶
</pre></div>
<p>如果非零，则该变量的值应该是一个正则表达式，匹配开始或分隔两个段落的行。正则表达式总是在换行符之后匹配，因此最好将其锚定，即以 <code>^</code> 开头。
</p>
<div class="lisp">
<pre class="lisp">
Variable: bidi-paragraph-separate-re ¶
</pre></div>
<p>如果非零，这个变量的值应该是一个正则表达式匹配一行分隔两个段落。正则表达式总是在换行符之后匹配，因此最好将其锚定，即以 <code>^</code> 开头。
</p>
<p>如果您修改这两个变量中的任何一个，您通常应该同时修改这两个变量，以确保它们一致地描述段落。例如，要让每个新行开始一个新段落以进行双向重新排序，请将两个变量都设置为 <code>^</code> 。
</p>
<p>默认情况下，Emacs 通过查看开头的文本来确定每个段落的基本方向。确定基准方向的精确方法由 UBA 规定；  简而言之，段落中具有明确方向性的第一个字符决定了段落的基本方向。但是，有时缓冲区可能需要为其段落强制使用某个基本方向。例如，包含程序源代码的缓冲区应该强制所有段落从左到右显示。您可以使用以下变量来执行此操作：
</p>
<div class="lisp">
<pre class="lisp">
User Option: bidi-paragraph-direction ¶
</pre></div>
<p>如果此缓冲区局部变量的值是符号从右到左或从左到右，则假定缓冲区中的所有段落都具有该指定方向。任何其他值都等效于 nil（默认值），这意味着从每个段落的内容确定每个段落的基本方向。
</p>
<p>程序源代码的模式应将其设置为从左到右。Prog 模式默认执行此操作，因此从 Prog 模式派生的模式不需要显式设置（请参阅基本主要模式）。
</p>
<div class="lisp">
<pre class="lisp">
Function: current-bidi-paragraph-direction &amp;optional buffer ¶
</pre></div>
<p>此函数返回命名缓冲区中某个点的段落方向。返回值是一个符号，从左到右或从右到左。如果缓冲区被省略或为零，则默认为当前缓冲区。如果变量 bidi-paragraph-direction 的缓冲区局部值非零，则返回值将与该值相同；  否则，返回值反映 Emacs 动态确定的段落方向。对于 bidi-display-reordering 值为 nil 的缓冲区以及单字节缓冲区，此函数始终从左到右返回。
</p>
<p>有时需要以严格的视觉顺序将点移动到当前屏幕位置的左侧或右侧。Emacs 提供了一个原语来做到这一点。
</p>
<div class="lisp">
<pre class="lisp">Function: move-point-visually direction ¶
</pre></div>
<p>此功能将当前选定窗口的点移动到屏幕上立即出现在右侧或左侧的缓冲区位置。方向为正时，point向右移动一屏位置，否则向左移动一屏位置。请注意，根据周围的双向上下文，这可能会将点移开许多缓冲区位置。如果在屏幕行的末尾调用，该函数将指针移动到下一个或上一个屏幕行的最右边或最左边的屏幕位置，以适应方向的值。
</p>
<p>该函数将新的缓冲区位置作为其值返回。
</p>
<p>当具有双向内容的两个字符串并列在缓冲区中或以其他方式以编程方式连接成文本字符串时，双向重新排序可能会产生令人惊讶和不愉快的效果。一个典型的有问题的情况是缓冲区由由空格或标点字符分隔的文本字段序列组成，例如缓冲区菜单模式或 Rmail 摘要模式。由于用作分隔符的标点符号方向性较弱，因此它们承担了周围文本的方向性。因此，在具有双向内容的字段之后的数字字段可能会显示在前一个字段的左侧，从而打乱了预期的布局。有几种方法可以避免这个问题：
</p>
<ul>
<li>
将特殊字符 U+200E LEFT-TO-RIGHT MARK 或 LRM 添加到可能具有双向内容的每个字段的末尾，或将其添加到后续字段的开头。如下所述的函数 bidi-string-mark-left-to-right 可用于此目的。（在从右到左的段落中，请改用 U+200F RIGHT-TO-LEFT MARK 或 RLM。）这是 UBA 推荐的解决方案之一。
</li><li>
在字段分隔符中包含制表符。制表符在双向重新排序中起到段分隔符的作用，导致两边的文本分别重新排序。
</li><li>
使用显示属性分隔字段或使用表单的属性值覆盖（空格 .PROPS）（请参阅指定空格）。Emacs 将此显示规范视为段落分隔符，并分别重新排序两侧的文本。
</li></ul>
<div class="lisp">
<pre class="lisp">Function: bidi-string-mark-left-to-right string ¶
</pre></div>
<p>此函数返回其参数字符串，可能已修改，以便结果可以安全地与另一个字符串连接，或与缓冲区中的另一个字符串并列，而不会破坏此字符串和显示的下一个字符串的相对布局。如果此函数返回的字符串显示为从左到右段落的一部分，则它将始终显示在其后文本的左侧。该函数通过检查其参数的字符来工作，如果这些字符中的任何一个可能导致显示重新排序，该函数会将 LRM 字符附加到字符串中。附加的 LRM 字符通过赋予其不可见文本属性 t 使其不可见（请参阅不可见文本）。
</p>
<p>重新排序算法使用存储的字符的双向属性作为它们的双向类属性（请参阅字符属性）。Lisp 程序可以通过调用 put-char-code-property 函数来更改这些属性。但是，这样做需要对 UBA 有透彻的了解，因此不建议这样做。对角色双向属性的任何更改都会产生全局影响：它们会影响所有 Emacs 框架和窗口。
</p>
<p>类似地，mirroring 属性用于在重新排序的文本中显示适当的镜像字符。Lisp 程序可以通过更改此属性来影响镜像显示。同样，任何此类更改都会影响所有 Emacs 显示。
</p>
<p>字符的双向属性可以通过在文本中插入特殊的方向控制字符 LEFT-TO-RIGHT OVERRIDE (LRO) 和 RIGHT-TO-LEFT OVERRIDE (RLO) 来覆盖。RLO 和后面的换行符或 POP DIRECTIONAL FORMATTING (PDF) 控制字符之间的任何字符（以先到者为准）将被显示为从右到左的强字符，即它们将在显示时反转。同样，LRO 和 PDF 或换行符之间的任何字符都将显示为从左到右的强字符，即使它们是从右到左的强字符也不会反转。
</p>
<p>当您希望使某些文本不受重新排序算法的影响，而是直接控制显示顺序时，这些覆盖非常有用。但它们也可用于恶意目的，即网络钓鱼。具体来说，可以操纵网页上的 URL 或电子邮件消息中的链接，使其视觉外观无法识别，或类似于某些流行的良性位置，而由浏览器按逻辑顺序解释的真实位置则大不相同.
</p>
<p>Emacs 提供了一个原语，应用程序可以使用该原语来检测其双向属性被覆盖的文本实例，从而使从左到右的字符显示为从右到左的字符，反之亦然。
</p>
<div class="lisp">
<pre class="lisp">Function: bidi-find-overridden-directionality from to &amp;optional object ¶
</pre></div>
<p>此函数查看从（包括）和到（不包括）位置之间的指定对象的文本，并返回它找到一个强从左到右字符的第一个位置，该字符的方向属性被强制显示为右- to-left，或强制显示为从左到右的强从右到左字符。如果在指定的文本区域中没有找到这样的字符，则返回 nil。
</p>
<p>可选参数对象指定要搜索的文本，默认为当前缓冲区。如果 object 不是 nil，它可以是其他缓冲区，也可以是字符串或窗口。如果它是一个字符串，该函数将搜索该字符串。如果它是一个窗口，则该函数搜索显示在该窗口中的缓冲区。如果您要检查其文本的缓冲区显示在某个窗口中，我们建议通过该窗口指定它，而不是将缓冲区传递给函数。这是因为告诉函数关于窗口允许它正确考虑特定于窗口的覆盖，如果缓冲区中的某些文本被覆盖覆盖，这可能会改变函数的结果。
</p>
<p>当包含混合的从右到左和从左到右字符和双向控件的文本复制到不同的位置时，它可以改变其视觉外观，也可以影响目标周围文本的视觉外观。这是因为由 UBA 指定的双向文本的重新排序对复制的文本和将围绕它的复制目标处的文本都具有重要的上下文相关影响。
</p>
<p>有时，Lisp 程序可能需要保留复制文本在目的地的确切视觉外观，以及副本周围的文本。Lisp 程序可以使用以下函数来实现该效果。
</p>
<div class="lisp">
<pre class="lisp">Function: buffer-substring-with-bidi-context start end &amp;optional no-properties ¶
</pre></div>
<p>此函数的工作方式类似于缓冲区子字符串（请参阅检查缓冲区内容），但它预先添加并附加到复制的文本双向控制字符，以在将文本插入另一个位置时保持文本的视觉外观。可选参数 no-properties，如果非 nil，则表示从文本副本中删除文本属性。
</p>
<hr size="6"/>

<div class="nav-panel"><p>Next: <a href="41_操作系统接口.html">操作系统接口</a>, Previous: <a href="40.25_工具提示.html">工具提示</a>, Up: <a href="40_Emacs显示.html">Emacs显示.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html>
<script>document.onkeydown=checkKey;function checkKey(e){if(e.keyCode=='39'){location="41_操作系统接口.html";}else if(e.keyCode=='37'){location="40.25_工具提示.html" } }</script>