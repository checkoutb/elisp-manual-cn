<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="elisp.css"><title>30.14 子帧</title></head><body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000"><h2 class="section">30.14 子帧</h2>
<div class="nav-panel"><p>Next: <a href="30.15_鼠标跟踪.html">鼠标跟踪</a>, Previous: <a href="30.13_帧配置.html">帧配置</a>, Up: <a href="30_帧.html">帧.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html><hr/><p>子帧是介于窗口（参见 Windows）和 <code>正常</code> 帧之间的对象。像窗户一样，它们连接到一个拥有的帧上。与窗口不同，它们可能会相互重叠——改变一个子帧的大小或位置不会改变其任何兄弟子帧的大小或位置。
</p>
<p>根据设计，制作或修改子帧的操作是在帧参数（参见帧参数）的帮助下实现的，无需任何专门的函数或可定制的变量。请注意，子帧仅在图形终端上有意义。
</p>
<p>要创建新的子帧或将普通帧转换为子帧，请将该帧的父帧参数（请参阅帧交互参数）设置为现有帧的参数。只要该参数未更改或重置，该参数指定的帧将成为该帧的父帧。从技术上讲，这使得子帧的窗口系统窗口成为父帧的窗口系统窗口的子窗口。
</p>
<p>parent-frame 参数可以随时更改。将其设置为另一个帧将重新设置子帧。将其设置为另一个子帧会使该帧成为嵌套子帧。将其设置为 nil 会将帧的状态恢复为顶级帧——其窗口系统窗口是其显示根窗口的子窗口的帧。
</p>
<p>由于子帧可以任意嵌套，因此一个帧既可以是子帧，也可以是父帧。此外，子帧和父帧的相对角色可以随时颠倒（尽管保持子帧的大小足够小于其父帧的大小通常是个好主意）。尝试使帧成为其自身的祖先时，将发出错误信号。
</p>
<p>大多数窗口系统在其父帧的本机边缘（请参阅帧几何）处剪辑一个子帧——这些边缘之外的所有东西通常都是不可见的。子帧的 left 和 top 参数指定相对于其父帧的左上角的位置。当父帧调整大小时，这个位置在概念上保持不变。
</p>
<p>NS 构建不会在父帧的边缘剪裁子帧，从而允许它们被定位，这样它们就不会遮挡父帧，同时它们本身仍然可见。
</p>
<p>通常，移动父帧会沿着其所有子帧及其后代移动，保持它们的相对位置不变。请注意，仅当子帧相对于其父帧的位置发生变化时，才会为子帧运行钩子移动帧功能（请参阅帧位置）。
</p>
<p>当父帧调整大小时，其子帧在概念上保留其先前的大小和它们相对于父帧左上角的位置。这意味着当父帧缩小时，子帧可能变得（部分）不可见。参数 keep-ratio（请参阅帧交互参数）可用于在调整父帧大小时按比例调整子帧的大小和重新定位。这可以避免在其父帧收缩时遮挡帧的某些部分。
</p>
<p>可见的子帧总是出现在其父帧的顶部，因此遮盖了它的一部分，除非在 NS 构建中它可能位于父帧之下。这类似于顶层帧的窗口系统窗口，它也始终出现在其父窗口（桌面的根窗口）的顶部。当父帧被图标化或使其不可见时（请参阅帧的可见性），其子帧将变为不可见。当父帧被取消图标化或可见时，其子帧变为可见。
</p>
<p>当一个父帧即将被删除时（参见删除帧），它的子帧在它之前被递归删除。此规则有一个例外：当子帧充当另一个帧的代理微型缓冲区帧（请参阅微型缓冲区和帧）时，它会一直保留到父帧被删除为止。如果此时没有剩余的帧使用子帧作为其 minibuffer 帧，Emacs 也会尝试删除子帧。如果该删除由于某种原因而失败，则子帧将成为顶级帧。
</p>
<p>子帧是否可以有菜单或工具栏取决于窗口系统或窗口管理器。大多数窗口系统明确禁止子帧的菜单栏。通过帧的初始参数设置禁用菜单和工具栏似乎是可取的。
</p>
<p>通常，子帧不显示窗口管理器装饰，如标题栏或外部边框（请参阅帧几何）。当子帧不显示菜单或工具栏时，可以使用帧的任何其他边框（请参阅布局参数）代替外部边框。
</p>
<p>特别是，在 X 下（但不是在使用 GTK+ 构建时），可以使用帧的外边框。在 MS-Windows 上，指定非零外边框宽度将显示一个像素宽的外边框。在所有窗口系统下，都可以使用内部边框。在任何一种情况下，建议使用 undecorated frame 参数禁用子帧的窗口管理器装饰（请参阅窗口管理参数）。
</p>
<p>要使用鼠标调整大小或移动未修饰的子帧，必须使用特殊的帧参数（请参阅鼠标拖动参数）。子帧的内部边框（如果存在）可用于使用鼠标调整帧的大小，前提是该帧具有非零的 drag-internal-border 参数。如果设置，则 snap-width 参数指示帧在其父帧的相应边缘或角处捕捉的像素数。
</p>
<p>有两种方法可以用鼠标拖动整个子帧： drag-with-mode-line 参数，如果非零，允许通过其最底部的模式行区域拖动没有 minibuffer 窗口的帧（参见 Minibuffer Windows）窗户。drag-with-header-line 参数，如果非零，允许通过其最顶部窗口的标题行区域拖动帧。
</p>
<p>为了给子帧一个可拖动的标题或模式行，窗口参数 mode-line-format 和 header-line-format 很方便（请参阅窗口参数）。这些允许删除不需要的模式线（选择标头线时）并删除可能干扰帧拖动的鼠标敏感区域。
</p>
<p>当用户用鼠标拖动一个帧并超出范围时，很容易将一个帧拖出其父级的屏幕区域。一旦释放鼠标按钮，检索这样的帧可能会很麻烦。为防止出现这种情况，建议设置帧的顶部可见或底部可见参数（请参阅鼠标拖动参数）。
</p>
<p>当您打算允许用户通过其标题行拖动该帧时，将子帧的 top-visible 参数设置为一个数字。将 top-visible 设置为数字会禁止将子帧的上边缘拖动到其父帧的上边缘之上。当您打算通过其模式线拖动该帧时，将底部可见参数设置为一个数字；  这禁止将子帧的底部边缘拖到其父帧的底部边缘下方。在任何一种情况下，该数字还指定在拖动期间保持可见的子帧区域的宽度和高度（以像素为单位）。
</p>
<p>当子帧用于通过 display-buffer-in-child-frame 显示缓冲区时（请参阅缓冲区显示的动作函数），可以将帧的自动隐藏函数参数（请参阅帧交互参数）设置为函数，为了在显示缓冲区的窗口应退出时适当地处理帧。
</p>
<p>当在 minibuffer 交互期间使用子帧时，例如，在单独的窗口中显示完成时，minibuffer-exit 参数（请参阅帧交互参数）对于在 minibuffer 退出时处理帧很有用。
</p>
<p>子帧的行为在许多其他方面也与顶级帧的行为有所不同。在这里，我们勾勒出其中的一些：
</p>
<p>最大化和图标化子帧的语义高度依赖于窗口系统。通常，应用程序永远不应该在子帧上调用这些操作。默认情况下，在子帧上调用 iconify-frame 将尝试图标化与该子帧对应的顶级帧。为了获得不同的行为，用户可以自定义下面描述的选项 iconify-child-frame。
提升、降低和重新堆叠子帧（请参阅提升、降低和重新堆叠帧）或更改子帧的 z 组（请参阅位置参数）只会更改具有相同父级的子帧的堆叠顺序。
许多窗口系统无法更改子帧的不透明度（请参阅字体和颜色参数）。
在某些窗口系统中，通过在祖先窗口的可见部分中单击鼠标将焦点从子帧转移到不是其父帧的祖先可能会失败。您可能必须先单击直接父级的窗口系统窗口。
窗口管理器可能不会费心将焦点按照鼠标策略扩展到子帧。自定义 mouse-autoselect-window 可以在这方面有所帮助（请参阅鼠标窗口自动选择）。
子帧上的拖放（请参阅拖放）不能保证在所有窗口系统上都有效。有些会将对象放在父帧或某个祖先上。
</p>
<p>在处理子帧和父帧时，以下两个函数很有用：
</p>
<div class="lisp">
<pre class="lisp">Function: frame-parent &amp;optional frame ¶
</pre></div>
<p>该函数返回frame的父frame。frame 的父帧是 Emacs 帧，其窗口系统窗口是帧的窗口系统窗口的父窗口。如果存在这样的帧，则认为帧是该帧的子帧。
</p>
<p>如果帧没有父帧，此函数返回 nil。
</p>
<div class="lisp">
<pre class="lisp">Function: frame-ancestor-p ancestor descendant ¶
</pre></div>
<p>如果祖先是后代的祖先，则此函数返回非零。当它是后代的父帧或者它是后代的父帧的祖先时，祖先是后代的祖先。祖先和后代都必须指定实时帧。
</p>
<p>还要注意函数 window-largest-empty-rectangle （参见坐标和窗口），它可用于在现有窗口的最大空白区域中嵌入子帧。这对于避免子帧遮盖该窗口中显示的任何文本很有用。
</p>
<p>自定义以下选项对于调整子帧的 iconify-frame 行为很有用。
</p>
<div class="lisp">
<pre class="lisp">User Option: iconify-child-frame ¶
</pre></div>
<p>此选项告诉 Emacs 在要求图标化子帧时如何继续。如果它是 nil，iconify-frame 在子帧上调用时什么也不做。如果它是 iconify-top-level，Emacs 将尝试图标化作为此子帧祖先的顶级帧。如果它是不可见的，Emacs 将尝试使这个子帧不可见而不是图标化它。
</p>
<p>任何其他值都意味着尝试图标化子帧。由于这种尝试可能不会被所有窗口管理器接受，甚至可能导致子帧对用户操作没有响应，因此默认情况下是图标化顶级帧。
</p>
<hr/>

<div class="nav-panel"><p>Next: <a href="30.15_鼠标跟踪.html">鼠标跟踪</a>, Previous: <a href="30.13_帧配置.html">帧配置</a>, Up: <a href="30_帧.html">帧.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html>