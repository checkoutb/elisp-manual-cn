<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="elisp.css"><title>35.3.1 正则表达式的语法</title></head><body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000"><h3 class="subsection">35.3.1 正则表达式的语法</h3>
<div class="nav-panel"><p>Next: <a href="35.3.2_复杂正则表达式示例.html">复杂正则表达式示例</a>, Previous: <a href="35.3_正则表达式.html">正则表达式</a>, Up: <a href="35.3_正则表达式.html">正则表达式.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html><hr/><p>正则表达式有一种语法，其中一些字符是特殊结构，其余的都是普通的。一个普通的字符是一个简单的正则表达式，它只匹配那个字符而不是别的。特殊字符有’.’、’*’、’+’、’?’、’[’、’^’、’$’和’\’；  将来不会定义新的特殊字符。如果字符 ’]’ 结束替代字符，则它是特殊的（见下文）。字符 <code>-</code> 在替代字符中是特殊的。’[:’ 和平衡 ’:]’ 将字符类包含在字符替代项中。正则表达式中出现的任何其他字符都是普通字符，除非它前面有一个 <code>\</code> 。
</p>
<p>例如，’f’不是特殊字符，所以是普通字符，因此’f’是匹配字符串’f’而不匹配其他字符串的正则表达式。（它不匹配字符串’fg’，但它匹配该字符串的一部分。）同样，’o’ 是一个只匹配’o’ 的正则表达式。
</p>
<p>任何两个正则表达式 a 和 b 都可以连接。结果是一个正则表达式，如果 a 匹配某个字符串的开头部分并且 b 匹配字符串的其余部分，则匹配该字符串。
</p>
<p>作为一个简单的例子，我们可以连接正则表达式’f’和’o’来得到正则表达式’fo’，它只匹配字符串’fo’。还是微不足道的。为了做一些更强大的事情，你需要使用一种特殊的正则表达式结构。
</p>
<ol>
<li>
35.3.1.1 正则表达式中的特殊字符


<p>以下是正则表达式中特殊字符的列表。
</p>
<div class="lisp">
<pre class="lisp">‘.’ (Period) ¶
</pre></div>
<p>是一个特殊字符，匹配除换行符以外的任何单个字符。使用连接，我们可以制作像 ’a.b’ 这样的正则表达式，它匹配任何以 ’a’ 开头并以 ’b’ 结尾的三个字符的字符串。
</p><div class="lisp">
<pre class="lisp">‘*’ ¶
</pre></div>
<p>本身不是一个构造；  它是一个后缀运算符，表示尽可能多地重复匹配前面的正则表达式。因此， <code>o*</code> 匹配任意数量的 <code>o</code> （包括没有 <code>o</code> ）。
</p>
<p>’*’ 始终适用于尽可能小的前面表达式。因此， <code>fo*</code> 有一个重复的 <code>o</code> ，而不是一个重复的 <code>fo</code> 。它匹配 <code>f</code> 、 <code>fo</code> 、 <code>foo</code> 等。
</p>
<p>匹配器通过立即匹配尽可能多的重复来处理 <code>*</code> 构造。然后它继续模式的其余部分。如果失败了，就会发生回溯，丢弃 <code>*</code> 修饰结构的一些匹配项，希望这样可以匹配模式的其余部分。例如，在匹配 ’ca*ar’ 和字符串 ’caaar’ 时，’a*’ 首先尝试匹配所有三个 ’a’；  但是模式的其余部分是 ’ar’ 并且只剩下 ’r’ 可以匹配，所以这个尝试失败了。下一个替代方案是让 ’a*’ 仅匹配两个 ’a’。选择此选项后，正则表达式的其余部分将成功匹配。
</p><div class="lisp">
<pre class="lisp">‘+’ ¶
</pre></div>
<p>是一个后缀运算符，类似于’*’，但它必须至少匹配前面的表达式一次。因此，例如，’ca+r’ 匹配字符串 ’car’ 和 ’caaaar’ 但不匹配字符串 ’cr’，而 ’ca*r’ 匹配所有三个字符串。
</p><div class="lisp">
<pre class="lisp">‘?’ ¶
</pre></div>
<p>是一个后缀运算符，类似于’*’，除了它必须匹配前面的表达式一次或根本不匹配。例如，’ca?r’ 匹配 ’car’ 或 ’cr’；  没有其他的。
</p><div class="lisp">
<pre class="lisp">‘*?’, ‘+?’, ‘??’ ¶
</pre></div>
<p>是运算符 ’*’、’+’ 和 ’?’ 的非贪婪变体。这些运算符匹配最大可能的子字符串（与匹配整个包含表达式一致），非贪婪变体匹配最小可能的子字符串（与匹配整个包含表达式一致）。
</p>
<p>例如，正则表达式 ’c[ad]*a’ 在应用于字符串 ’cdaaada’ 时匹配整个字符串；  但是应用于同一字符串的正则表达式 <code>c[ad]*?a</code> 只匹配 <code>cda</code> 。（这里允许整个表达式匹配的 ’[ad]*?’ 的最小可能匹配是 ’d’。）
</p><div class="lisp">
<pre class="lisp">‘[ … ]’ ¶
</pre></div>
<p>是一个替代字符，以 <code>[</code> 开头，以 <code>]</code> 结尾。在最简单的情况下，两个括号之间的字符就是这个替代字符可以匹配的字符。
</p>
<p>因此，’[ad]’ 匹配一个 ’a’ 或一个 ’d’，而 ’[ad]*’ 匹配任何仅由 ’a’s 和 ’d’s 组成的字符串（包括空字符串）。’c[ad]*r’ 匹配 ’cr’、’car’、’cdr’、’caddaar’ 等。
</p>
<p>您还可以在替代字符中包含字符范围，方法是在起始字符和结束字符之间用 <code>-</code> 书写。因此，’[az]’ 匹配任何小写的 ASCII 字母。范围可以与单个字符自由混合，如 ’[az’、’%’ 或句点。但是，一个范围的结束字符不应该是另一个范围的起点；  例如，应该避免使用 <code>[amz]</code> 。
</p>
<p>替代字符还可以指定命名字符类（请参阅字符类）。这是一个 POSIX 功能。例如， <code>[[:ascii:]]</code> 匹配任何 ASCII 字符。使用一个字符类相当于提到该类中的每个字符；  但后者在实践中是不可行的，因为有些类包含数千个不同的字符。字符类不应显示为范围的下限或上限。
</p>
<p>通常的正则表达式特殊字符在字符替代中并不特殊。一组完全不同的字符是特殊的：’]’、’-’ 和 ’^’。要在替代字符中包含 <code>]</code> ，请将其放在开头。要包含 <code>^</code> ，请将其放在除开头之外的任何位置。要包括 <code>-</code> ，请将其放在末尾。因此，’[]^-]’ 匹配所有这三个特殊字符。您不能使用 ’\’ 转义这三个字符，因为 ’\’ 在这里并不特殊。
</p>
<p>范围的以下方面特定于 Emacs，因为 POSIX 允许但不要求这种行为，并且 Emacs 以外的程序可能会有不同的行为：
</p>
<p>如果 case-fold-search 不为 nil，则 ’[az]’ 也匹配大写字母。
范围不受语言环境的排序顺序影响：它始终表示代码点介于其边界之间的字符集，因此 ’[az]’ 仅匹配 ASCII 字母，即使在 C 或 POSIX 语言环境之外。
如果范围的下限大于其上限，则该范围为空且不代表任何字符。因此，’[za]’ 总是无法匹配，而 ’[<em>^za</em>]’ 匹配任何字符，包括换行符。但是，颠倒的范围应该始终是从字母 <code>z</code> 到字母 <code>a</code> ，以表明它不是拼写错误；  例如，应该避免使用 <code>[+-*/]</code> ，因为它只匹配 <code>/</code> 而不是可能的四个字符。
如果范围的端点是原始 8 位字节（请参阅文本表示），或者如果范围开始是 ASCII 并且结束是原始字节（如在 ’[a-\377]’ 中），则范围将匹配只有 ASCII 字符和原始 8 位字节，但不是非 ASCII 字符。此功能旨在搜索单字节缓冲区和字符串中的文本。
</p>
<p>某些类型的字符替代不是最好的样式，即使它们在 Emacs 中具有明确的含义。它们包括：
</p>
<p>尽管范围的界限几乎可以是任何字符，但最好保持在 ASCII 字母和数字的自然序列内，因为大多数人没有记住字符代码表。例如， <code>[.-9]</code> 不如 <code>[./0-9]</code> 清晰， <code>[`-~]</code> 不如 <code>[`az{|}~]</code> 清晰。Unicode 字符转义在这里可以提供帮助；  例如，对于大多数程序员来说， <code>[ก-ฺ฿-๛]</code> 不如 <code>[\u0E01-\u0E3A\u0E3F-\u0E5B]</code> 清晰。
尽管字符替代可以包含重复，但最好避免它们。例如， <code>[XYa-yYb-zX]</code> 不如 <code>[XYa-z]</code> 清晰。
虽然一个范围只能表示一个、两个或三个字符，但列出这些字符更简单。例如， <code>[a-a0]</code> 不如 <code>[a0]</code> 清晰， <code>[ij]</code> 不如 <code>[ij]</code> 清晰， <code>[ik]</code> 不如 <code>[ijk]</code> 清晰.
尽管 <code>-</code> 可以出现在替代字符的开头或作为范围的上限，但最好将 <code>-</code> 单独放在替代字符的末尾。例如，虽然 ’[-az]’ 是有效的，但 ’[az-]’ 是更好的样式；  尽管 ’[*–]’ 有效，但 ’[*+,-]’ 更清晰。
</p>
<div class="lisp">
<pre class="lisp">‘[^ … ]’ ¶
</pre></div>
<p>’[^’ 开始一个补充字符替代。这匹配除指定字符之外的任何字符。因此，’[<em>^a</em>-z0-9A-Z]’ 匹配除 ASCII 字母和数字之外的所有字符。
</p>
<p>’^’ 在替代字符中并不特殊，除非它是第一个字符。’^’ 后面的字符被视为第一个字符（换句话说，’-’ 和 ’]’ 在那里并不特殊）。
</p>
<p>补充字符替代可以匹配换行符，除非换行符被提及为不匹配的字符之一。这与 grep 等程序中正则表达式的处理形成对比。
</p>
<p>您可以指定命名字符类，就像在字符替代中一样。例如，’[^[:ascii:]]’ 匹配任何非 ASCII 字符。请参阅字符类。
</p><div class="lisp">
<pre class="lisp">‘^’ ¶
</pre></div>
<p>匹配缓冲区时，’^’ 匹配空字符串，但仅在被匹配文本的行首（或缓冲区可访问部分的开头）。否则它无法匹配任何东西。因此，’<em>^foo</em>’ 匹配出现在行首的 ’foo’。
</p>
<p>当匹配字符串而不是缓冲区时，’^’ 匹配字符串的开头或换行符之后。
</p>
<p>出于历史兼容性的原因，’^’ 只能用在正则表达式的开头，或者在 ’\(’、’\(?:’ 或 ’\|’ 之后。
</p><div class="lisp">
<pre class="lisp">‘$’ ¶
</pre></div>
<p>类似于 ’^’ 但仅匹配行尾（或缓冲区可访问部分的末尾）。因此，’x+$’ 匹配行尾有一个或多个 ’x’ 的字符串。
</p>
<p>当匹配字符串而不是缓冲区时，’$’ 匹配字符串末尾或换行符之前。
</p>
<p>出于历史兼容性的原因，’$’ 只能用在正则表达式的末尾，或者在 ’\)’ 或 ’\|’ 之前。
</p><div class="lisp">
<pre class="lisp">‘\’ ¶
</pre></div>
<p>有两个功能：它引用特殊字符（包括’\’），它引入了额外的特殊结构。
</p>
<p>因为’\’引用了特殊字符，’\’的正则表达式，’\[’是一个只匹配’[’的正则表达式，以此类推。
</p>
<p>请注意，’\’ 在 Lisp 字符串的读取语法中也有特殊含义（请参阅字符串类型），并且必须用 ’\’ 引用。例如，匹配 <code>\</code> 字符的正则表达式是 <code>\\</code> 。要编写一个包含字符 ’\\’ 的 Lisp 字符串，Lisp 语法要求您用另一个 ’\’ 引用每个 ’\’。因此，匹配 <code>\</code> 的正则表达式的读取语法是 <code>\\\\</code> 。
</p>
<p>请注意：为了历史兼容性，如果特殊字符在其特殊含义没有意义的上下文中，它们将被视为普通字符。例如，’<strong>foo’ 将 ’</strong>’ 视为普通的，因为没有前面的表达式可以让 ’*’ 起作用。依赖这种行为是不好的做法；  无论如何都要引用特殊字符，无论它出现在哪里。
</p>
<p>由于 ’\’ 在替代字符中并不特殊，因此它永远无法删除 ’-’ 或 ’]’ 的特殊含义。因此，当它们没有特殊含义时，您也不应该引用这些字符。这不会澄清任何事情，因为反斜杠可以合法地放在这些具有特殊含义的字符之前，例如 ’[^\]’ （ <code>[^\\]</code>  用于 Lisp 字符串语法），它匹配除反斜杠之外的任何单个字符。
</p>
<p>在实践中，正则表达式中出现的大多数 ’]’ 都关闭了替代字符，因此是特殊的。但是，有时正则表达式可能会尝试匹配文字 <code>[</code> 和 <code>]</code> 的复杂模式。在这种情况下，有时可能需要从头开始仔细分析正则表达式，以确定哪些方括号包含替代字符。例如，’[^][]]’ 由补码替代字符 ’[^][]’（匹配任何不是方括号的单个字符），后跟文字 ’]’。
</p>
<p>确切的规则是，在正则表达式的开头，’[’ 是特殊的，而 ’]’ 不是。这一直持续到第一个未引用的’[’，之后我们处于字符替代状态；  ’[’ 不再特殊（除非它开始一个字符类），但 ’]’ 是特殊的，除非它紧跟特殊的 ’[’ 或 ’[’ 后跟一个 ’^’。这一直持续到下一个不结束字符类的特殊 <code>]</code> 。这结束了字符替代并恢复了正则表达式的普通语法；  未加引号的 ’[’ 又是特殊的，而 ’]’ 则不是。
</p>
</li><li>
35.3.1.2 字符类


<p>下表列出了您可以在字符替代中使用的类，以及它们的含义。请注意，包含类名的 ’[’ 和 ’]’ 字符是名称的一部分，因此使用这些类的正则表达式还需要一对括号。例如，匹配一个或多个字母和数字序列的正则表达式将是 <code>[[:alnum:]]+</code> ，而不是 <code>[:alnum:]+</code> 。
</p>
<div class="lisp">
<pre class="lisp">‘[:ascii:]’
</pre></div>
<p>这匹配任何 ASCII 字符（代码 0–127）。
</p><div class="lisp">
<pre class="lisp">‘[:alnum:]’
</pre></div>
<p>这匹配任何字母或数字。对于多字节字符，它匹配 Unicode ’general-category’ 属性（请参阅字符属性）指示它们是字母或十进制数字字符的字符。
</p><div class="lisp">
<pre class="lisp">‘[:alpha:]’
</pre></div>
<p>这匹配任何字母。对于多字节字符，它匹配其 Unicode ’general-category’ 属性（请参阅字符属性）指示它们是字母字符的字符。
</p><div class="lisp">
<pre class="lisp">‘[:blank:]’
</pre></div>
<p>这与 Unicode 技术标准 #18 的附件 C 中定义的水平空格相匹配。特别是，它匹配空格、制表符和其他字符，其 Unicode ’general-category’ 属性（请参阅字符属性）表明它们是间距分隔符。
</p><div class="lisp">
<pre class="lisp">‘[:cntrl:]’
</pre></div>
<p>这匹配代码在 0-31 范围内的任何字符。
</p><div class="lisp">
<pre class="lisp">‘[:digit:]’
</pre></div>
<p>这匹配 <code>0</code> 到 <code>9</code> 。因此，’[-[:digit:]]’ 匹配任何数字，以及 ” 和 ’-’。
</p><div class="lisp">
<pre class="lisp">‘[:graph:]’
</pre></div>
<p>这匹配图形字符——除空格、ASCII 和非 ASCII 控制字符、代理项和 Unicode 未分配的代码点之外的所有字符，如 Unicode ’general-category’ 属性所示（请参阅字符属性）。
</p><div class="lisp">
<pre class="lisp">‘[:lower:]’
</pre></div>
<p>这匹配任何由当前大小写表确定的小写字母（请参阅案例表）。如果 case-fold-search 不为零，则它也匹配任何大写字母。
</p><div class="lisp">
<pre class="lisp">‘[:multibyte:]’
</pre></div>
<p>这匹配任何多字节字符（请参阅文本表示）。
</p><div class="lisp">
<pre class="lisp">‘[:nonascii:]’
</pre></div>
<p>这匹配任何非 ASCII 字符。
</p><div class="lisp">
<pre class="lisp">‘[:print:]’
</pre></div>
<p>这匹配任何打印字符——空格或由 ’[:graph:]’ 匹配的图形字符。
</p><div class="lisp">
<pre class="lisp">‘[:punct:]’
</pre></div>
<p>这匹配任何标点符号。（目前，对于多字节字符，它匹配任何具有非单词语法的内容。）
</p><div class="lisp">
<pre class="lisp">‘[:space:]’
</pre></div>
<p>这匹配任何具有空格语法的字符（请参阅语法类表）。
</p><div class="lisp">
<pre class="lisp">‘[:unibyte:]’
</pre></div>
<p>这匹配任何单字节字符（请参阅文本表示）。
</p><div class="lisp">
<pre class="lisp">‘[:upper:]’
</pre></div>
<p>这匹配任何大写字母，由当前大小写表确定（请参阅案例表）。如果 case-fold-search 不为零，则它也匹配任何小写字母。
</p><div class="lisp">
<pre class="lisp">‘[:word:]’
</pre></div>
<p>这匹配任何具有单词语法的字符（请参阅语法类表）。
</p><div class="lisp">
<pre class="lisp">‘[:xdigit:]’
</pre></div>
<p>这匹配十六进制数字： <code>0</code> 到 <code>9</code> 、 <code>a</code> 到 <code>f</code> 和 <code>A</code> 到 <code>F</code> 。
</p>
</li><li>
35.3.1.3 正则表达式中的反斜杠结构


<p>大多数情况下，’\’ 后跟任何字符都只匹配该字符。但是，有几个例外：某些以 ’\’ 开头的具有特殊含义的序列。这是一个特殊的 <code>\</code> 结构表。
</p>
<div class="lisp">
<pre class="lisp">‘\|’ ¶
</pre></div>
<p>指定替代方案。两个带有 ’\|’ 的正则表达式 a 和 b  在中间形成一个匹配任何 a 或 b 匹配的表达式的表达式。
</p>
<p>因此，’foo\|bar’ 匹配 ’foo’ 或 ’bar’ 但不匹配其他字符串。
</p>
<p>’\|’  适用于最大可能的周围表达式。只有周围的 ” 分组才能限制 ’\|’ 的分组能力。
</p>
<p>如果您需要完整的回溯功能来处理 ’\|’ 的多次使用，请使用 POSIX 正则表达式函数（请参阅 POSIX 正则表达式搜索）。
</p><div class="lisp">
<pre class="lisp">‘\{m\}’
</pre></div>
<p>是一个后缀运算符，它恰好重复前一个模式 m 次。因此，’x\{5\}’ 与字符串 ’xxxxx’ 匹配，仅此而已。’c[ad]\{3\}r’ 匹配字符串，例如 ’caaar’、’cdddr’、’cadar’ 等。
</p><div class="lisp">
<pre class="lisp">‘\{m,n\}’
</pre></div>
<p>是一个更通用的后缀运算符，它指定最少 m 次重复和最多 n 次重复的重复。如果省略 m，则最小值为 0；  如果 n 被省略，则没有最大值。对于这两种形式，如果指定，m 和 n 不得大于 2**16 - 1 。
</p>
<p>例如，’c[ad]\{1,2\}r’ 匹配字符串 ’car’、’cdr’、’caar’、’cadr’、’cdar’ 和 ’cddr’，仅此而已。
’\{0,1\}’ 或 ’\{,1\}’ 等价于 ’?’。
’\{0,\}’ 或 ’\{,\}’ 等价于 ’*’。
’\{1,\}’ 等价于 ’+’。
</p><div class="lisp">
<pre class="lisp">‘\( … \)’ ¶
</pre></div>
<p>是一个用于三个目的的分组结构：
</p>
<p>包含一组 ’\|’  其他操作的替代方案。因此，正则表达式 ’x’ 匹配 ’foox’ 或 ’barx’。
为后缀运算符 ’<strong>’、’+’ 和 ’?’ 括起来一个复杂的表达式 操作。因此，’ba</strong>’ 匹配 ’ba’、’bana’、’banana’、’bananana’ 等，以及任意数量（零个或更多）的 ’na’ 字符串。
使用 ” 记录匹配的子字符串以供将来参考（见下文）。
</p>
<p>最后一个应用不是括号分组概念的结果。它是一个单独的特征，作为第二个含义分配给同一个 ” 结构，因为在实践中，这两个含义之间通常没有冲突。但偶尔会发生冲突，这导致引入了害羞的群体。
</p><div class="lisp">
<pre class="lisp">‘\(?: … \)’ ¶
</pre></div>
<p>是害羞的群体结构。shy 组服务于普通组的前两个目的（控制其他运算符的嵌套），但它没有得到数字，所以你不能用 ” 引用它的值。害羞组对于机械构造的正则表达式特别有用，因为它们可以自动添加而无需更改普通非害羞组的编号。
</p>
<p>害羞组也称为非捕获组或未编号组。
</p>
<p>是明确编号的组结构。普通组会根据他们的位置隐含地获得他们的号码，这可能很不方便。此构造允许您强制使用特定的组号。编号没有特别的限制，例如，您可以有多个具有相同编号的组，在这种情况下，最后匹配的一组（即最右边的匹配）将获胜。隐式编号的组总是得到大于任何前一组的最小整数。
</p>
<div class="lisp">
<pre class="lisp">‘\(?num: … \)’
</pre></div>
<p>匹配与分组 (”) 构造的第 digit 次出现匹配的相同文本。
</p>
<p>换句话说，在一个组结束后，匹配器会记住该组匹配的文本的开头和结尾。稍后在正则表达式中，您可以使用 ’\’ 后跟数字来匹配相同的文本，无论它可能是什么。
</p>
<p>与传递给搜索或匹配函数的整个正则表达式中出现的前九个分组结构相匹配的字符串按照左括号在正则表达式中出现的顺序分配编号 1 到 9。因此，您可以使用 ’\1’ 到 ’\9’ 来引用由相应分组结构匹配的文本。
</p>
<p>例如，’\1’ 匹配任何由两个相同部分组成的无换行符字符串。” 匹配前半部分，可以是任何内容，但后面的 ’\1’ 必须匹配完全相同的文本。
</p>
<p>如果一个 ” 构造匹配不止一次（这可能发生，例如，如果它后跟 ’*’），则只记录最后一个匹配。
</p>
<p>如果正则表达式中的特定分组结构从未匹配过——例如，如果它出现在未使用的替代项中，或者出现在重复零次的重复项中——则相应的 ” 结构永远不会匹配任何内容.  举一个人为的例子，’\|lose\)\2’ 不能匹配 ’lose’：较大组内的第二个选择匹配它，但是 ’\2’ 是未定义的并且可以不匹配任何东西。但它可以匹配 ’foobb’，因为第一个替代匹配 ’foob’ 而 ’\2’ 匹配 ’b’。
</p><div class="lisp">
<pre class="lisp">‘\w’ ¶
</pre></div>
<p>匹配任何单词组成字符。编辑器语法表确定这些是哪些字符。请参阅语法表。
</p>
<div class="lisp">
<pre class="lisp">‘\W’ ¶
</pre></div>
<p>匹配任何不是单词成分的字符。
</p><div class="lisp">
<pre class="lisp">‘\scode’ ¶
</pre></div>
<p>匹配任何语法为代码的字符。这里的 code 是一个表示语法代码的字符：因此，’w’ 表示单词组成，’-’ 表示空格，’(’ 表示左括号等。要表示空格语法，请使用 ’-’ 或空格字符。有关语法代码和代表它们的字符的列表，请参阅语法类表。
</p><div class="lisp">
<pre class="lisp">‘\Scode’ ¶
</pre></div>
<p>匹配语法不是代码的任何字符。
</p><div class="lisp">
<pre class="lisp">‘\cc’
</pre></div>
<p>匹配任何类别为 c 的字符。这里 c 是一个表示类别的字符：因此，在标准类别表中， <code>c</code> 表示中文字符或 <code>g</code> 表示希腊字符。您可以使用 Mx describe-categories RET 查看所有当前定义的类别列表。除了使用 define-category 函数的标准类别之外，您还可以定义自己的类别（请参阅类别）。
</p>
<div class="lisp">
<pre class="lisp">‘\Cc’
</pre></div>
<p>匹配任何类别不是 c 的字符。
</p>
<p>以下正则表达式构造匹配空字符串——也就是说，它们不使用任何字符——但它们是否匹配取决于上下文。总而言之，缓冲区可访问部分的开头和结尾被视为缓冲区的实际开头和结尾。
</p>
<div class="lisp">
<pre class="lisp">‘\`’ ¶
</pre></div>
<p>匹配空字符串，但仅在要匹配的缓冲区或字符串的开头。
</p><div class="lisp">
<pre class="lisp">‘\'’ ¶
</pre></div>
<p>匹配空字符串，但仅在要匹配的缓冲区或字符串的末尾。
</p><div class="lisp">
<pre class="lisp">‘\=’ ¶
</pre></div>
<p>匹配空字符串，但仅在点。（与字符串匹配时未定义此构造。）
</p><div class="lisp">
<pre class="lisp">‘\b’ ¶
</pre></div>
<p>匹配空字符串，但仅在单词的开头或结尾。因此，” 将任何出现的 ’foo’ 匹配为单独的单词。’?’ 匹配 ’ball’ 或 ’balls’ 作为单独的词。
</p>
<p>” 匹配缓冲区（或字符串）的开头或结尾，无论它旁边出现什么文本。
</p><div class="lisp">
<pre class="lisp">‘\B’ ¶
</pre></div>
<p>匹配空字符串，但不在单词的开头或结尾，也不在缓冲区（或字符串）的开头或结尾。
</p><div class="lisp">
<pre class="lisp">‘\&lt;’ ¶
</pre></div>
<p>匹配空字符串，但仅在单词的开头。’\&lt;’ 匹配缓冲区（或字符串）的开头，仅当后面有单词组成字符时。
</p><div class="lisp">
<pre class="lisp">‘\&gt;’ ¶
</pre></div>
<p>匹配空字符串，但仅在单词的末尾。’\&gt;’ 仅当内容以单词组成字符结尾时才匹配缓冲区（或字符串）的末尾。
</p><div class="lisp">
<pre class="lisp">‘\_&lt;’ ¶
</pre></div>
<p>匹配空字符串，但仅在符号的开头。符号是一个或多个单词或符号组成字符的序列。’\_&lt;’ 仅在符号组成字符后跟在缓冲区（或字符串）的开头匹配。
</p><div class="lisp">
<pre class="lisp">‘\_&gt;’ ¶
</pre></div>
<p>匹配空字符串，但仅在符号的末尾。’\_&gt;’ 仅当内容以符号组成字符结尾时才匹配缓冲区（或字符串）的末尾。
</p>
<p>并非每个字符串都是有效的正则表达式。例如，以替代字符结尾而没有终止 <code>]</code> 的字符串是无效的，以单个 <code>\</code> 结尾的字符串也是如此。如果将无效的正则表达式传递给任何搜索函数，则会发出无效正则表达式错误信号。
</p></li></ol>
<hr/>

<div class="nav-panel"><p>Next: <a href="35.3.2_复杂正则表达式示例.html">复杂正则表达式示例</a>, Previous: <a href="35.3_正则表达式.html">正则表达式</a>, Up: <a href="35.3_正则表达式.html">正则表达式.</a> &nbsp; [<a href="00_content.htm" title="Table of contents" rel="contents">Contents</a>]</p></div></body></html>
<script>document.onkeydown=checkKey;function checkKey(e){if(e.keyCode=='39'){location="35.3.2_复杂正则表达式示例.html";}else if(e.keyCode=='37'){location="35.3_正则表达式.html" } }</script>